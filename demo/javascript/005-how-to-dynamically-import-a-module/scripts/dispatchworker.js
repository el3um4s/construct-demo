'use strict';self.inputPort=null;self.jobQueue=[];self.jobWorkers=[];self.sentBlobs=[];self.sentBuffers=[];self.importedScripts=[];self.lastBroadcasts=new Map;
class JobWorker{constructor(a,b){this._port=a;this._number=b;this._isBusy=this._isReady=!1;this._port.onmessage=a=>this._OnMessage(a.data)}ImportScripts(a){this._port.postMessage({type:"_import_scripts",scripts:a})}SendBlob(a,b){this._port.postMessage({type:"_send_blob",blob:a,id:b})}SendBuffer(a,b){this._port.postMessage({type:"_send_buffer",buffer:a,id:b})}SendJob(a){if(this._isBusy||!this._isReady)throw Error("cannot take job");this._isBusy=!0;this._port.postMessage(a,a.transferables)}_InitBroadcast(a){this._port.postMessage(a,
a.transferables)}SendReady(){this._port.postMessage({type:"_ready"})}IsReady(){return this._isReady}_OnReady(){this._isReady=!0;this.MaybeStartNextJob()}IsBusy(){return this._isBusy}GetNumber(){return this._number}_OnMessage(a){a=a.type;switch(a){case "ready":this._OnReady();break;case "done":this._OnJobDone();break;default:console.error("unknown message from worker '"+a+"'")}}_OnJobDone(){this._isBusy=!1;this.MaybeStartNextJob()}MaybeStartNextJob(){if(!this._isBusy&&this._isReady){var a=this._FindAvailableJob();
if(-1!==a){var b=self.jobQueue[a];b.isBroadcast?(b.doneFlags[this._number]=!0,b.doneFlags.every(a=>a)&&self.jobQueue.splice(a,1)):self.jobQueue.splice(a,1);this.SendJob(b)}}}_FindAvailableJob(){for(let a=0,b=self.jobQueue.length;a<b;++a){const b=self.jobQueue[a];if(!b.isBroadcast||this._number<b.doneFlags.length&&!b.doneFlags[this._number])return a}return-1}TestMessageChannel(){this._port.postMessage({type:"_testMessageChannel"})}}let number=0;
function AddJobWorker(a){a=new JobWorker(a,number++);self.jobWorkers.push(a);for(const [b,c]of self.sentBlobs)a.SendBlob(b,c);for(const [b,c]of self.sentBuffers)a.SendBuffer(b,c);for(const b of self.importedScripts)a.ImportScripts(b);for(const b of self.lastBroadcasts.values())a._InitBroadcast(b);a.SendReady()}function CancelJob(a){for(let b=0,c=self.jobQueue.length;b<c;++b)if(self.jobQueue[b].jobId===a){self.jobQueue.splice(b,1);break}}
self.addEventListener("message",a=>{a=a.data;const b=a.type;"_init"===b?(self.inputPort=a["in-port"],self.inputPort.onmessage=OnInputPortMessage):"_addJobWorker"===b&&AddJobWorker(a.port)});
function OnInputPortMessage(a){a=a.data;const b=a.type;if("_cancel"===b)CancelJob(a.jobId);else if("_import_scripts"===b){var c=a.scripts;for(const a of self.jobWorkers)a.ImportScripts(c);self.importedScripts.push(c)}else if("_send_blob"===b){var d=a.blob;a=a.id;for(c of self.jobWorkers)c.SendBlob(d,a);self.sentBlobs.push([d,a])}else if("_send_buffer"===b){c=a.buffer;a=a.id;for(d of self.jobWorkers)d.SendBuffer(c,a);self.sentBuffers.push([c,a])}else if("_no_more_workers"===b)self.sentBlobs.length=
0,self.sentBuffers.length=0,self.importedScripts.length=0,self.lastBroadcasts.clear();else if("_testMessageChannel"===b)self.jobWorkers[0].TestMessageChannel();else{self.jobQueue.push(a);a.isBroadcast&&(a.doneFlags=Array(self.jobWorkers.length).fill(!1),a.transferables=[],self.lastBroadcasts.set(a.type,a));for(const a of self.jobWorkers)a.MaybeStartNextJob()}};
